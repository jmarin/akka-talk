<!DOCTYPE html>
<html>
  <head>
    <title>Akka</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# Akka

### Building high performance backends in a distributed world

Created by Juan Marin Otero / [@jmarinotero](http://twitter.com/jmarinotero)

---

# Agenda

1. Introduction
2. What is Akka?
3. Actors
4. Futures
5. Utilities
6. Clustering
7. Persistence
8. Streams


---

# About me

* Solutions Architect @Chief, HMDA Team
* Have been doing GIS software development for +15 years
* Open Source contributor (GeoServer, GeoGit)
* Previously: 
  - CTO at Boundless
  - Lead Developer for the National Broadband Map at the FCC
  - Solutions Engineer at Esri

---

# The Reactive Manifesto

![Reactive Manifesto](img/reactive-traitsv2.png)

---
![Akka](img/akka_full_color.svg)

## _"Akka is a toolkit and runtime for building highly concurrent, distributed, and resilient message-driven applications on the JVM."_

---

# Actor Model

* Objects which encapsulate state and behavior
* Can only communicate with them by sending messages
* Mailbox (message queue) => process one message at a time
* They *share nothing* with other actors
* Event based processes, very lightweight. ~400 bytes in memory, millions / GB of RAM
* _Location Transparency_ => Distributable across a cluster of machines
* Two types of messages:
  - ! (bang operator) Fire and forget, returns inmmediately.
  - ? (ask operator) sends message and returns a Future representing a possible reply at a later point in time

---

# Fault Tolerance

Actors form _supervision hierarchies_.

![Actor Supervision](img/actor-hierarchy.png)

---

# Actors: Hello World

```scala

case object Greeting

class HelloActor extends Actor {
  def receive = {
    case Greeting => println("Hello World")
    case _ => "I don't understand this message"
  }
}
```

In order to run this we need an `ActorSystem` (runtime) and we need to start the actor:

```scala
val system = ActorSystem("system")
val helloActor = system.actorOf(Props[HelloActor], "hello-actor")

```

Now we can send messages to it:

```scala
helloActor ! Greeting
```
---

# Actors example: Chat application

---

# Futures 

### _A data structure used to retrieve the result of some concurrent operation. This result can be accessed synchronously (blocking) or asynchronously (non-blocking)_

Think of it as a read-only placeholder object for a result that doesn't exist yet

Futures require an `ExecutionContext` to work, it is similar to a `java.util.concurrent.Executor` and allows computations to operate in a new thread, a thread pool or onthe current thread (the last option is discouraged).

The `scala.concurrent` package has `ExecutionContext.global` which is backed by a `ForkedJoinPool` thread pool, which allows programs to take advantage of multiple processors by submitting tasks to the pool thread. Execution contexts are configurable in Akka. 

---

# Futures: callbacks

```scala
import scala.util.{Success, Failure}

val f: Future[List[String]] = Future {
  session.getRecentPosts
}

f onComplete {
  case Success(posts) => for (post <- posts) println(post)
  case Failure(t) => println("An error has occured: " + t.getMessage)
}
```

You can also go just through the "happy path"

```scala
f onSuccess {
  case posts => for (post <- posts) println(post)
}
```

---
# Futures: Functional composition and for-comprehensions

Futures _compose_, allows us to describe parallel computations easily. The following code snippet will wait until both Futures have completed, then return

```scala
import scala.concurrent._
import scala.concurrent.duration._

def geocodePoint(parsed: ParsedAddress)
def geocodeCensus(parsed: ParsedAddress)

val r = for {
  p <- geocodePoint(address)
  c <- geocodeCensus(address)              
} yield (Result(p, c))

println(Await.result(r, 1 seconds))
```

*Important: * `Await.result` blocks until the future completes. Never use this in real code (it is OK for testing)

---
# Actors and Futures

The ask (`?`) operator returns a Future

```scala
val apiResponse: Future[String] = actorRef ? Request(payload:String)
```

This model is used a lot when sending messages through asynchronous boundaries. 
              
An alternative is to model the request-response cycle as a series of Actor messages (becomes more complicated, but has no timeout issues).

The result can be transformed using functional programming techniques:

```scala
val employeeList = (actorRef ? GetEmployees).mapTo[List[Employee]].map(_.name)
```

This will return a `Future[List[String]]`, it first gets a `Future[List[Employee]]` and then maps the result to each employee's name (a String)

---


# Utilities

* Event Bus
* Scheduler
* Circuit Breaker

---

# Clustering

---

# Persistence

---

# Streams

---

# Case Study: HMDA

### Home Mortgage Disclosure Act (HMDA)

* Provide the citizens and public officials of the U.S. sufficient information:
   - to enable them to determine whether covered institutions are filling their obligations to serve the housing needs of the communities and neighborhoods in which they are located; and 
   - to assist public officials in distributing public sector investments in a manner designed to improve the private environment.

* Assist in identifying possible discriminatory lending patterns and enforcing antidiscrimination statutes.

* Enhanced understanding of mortgage markets.

---

# HMDA: some challenges

* Data Ingestion
  - ~7500 Financial Institutions file individual loan data
  - 10 - 20 million records / year. Over 30 years of history
  - It all comes at the same time → huge spike

* Data publication
  - We don’t know what this will look like yet, but most likely we will have several different publication streams
  - Time to market. Now 6 months, we have to do 1 month (modified LAR). It should be 1 day or less
  - Most value is in time series and geographic analysis

* Data Management
  - We need to version every loan to keep track of it through time (100% audit trail)
  - We don’t know what questions we will ask of this data in the future
  - Data will grow significantly, adding new fields
  - Schema has changed and will change in the future









    </textarea>
    <script src="https://gnab.github.io/remark/downloads/remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create();
    </script>
  </body>
</html>
