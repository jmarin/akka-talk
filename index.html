<!DOCTYPE html>
<html>
  <head>
    <title>Akka</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# Akka

### Building high performance backends in a distributed world

Created by Juan Marin Otero / [@jmarinotero](http://twitter.com/jmarinotero)

---

# Agenda

1. Introduction
2. What is Akka?
3. Actors
4. Futures
5. Utilities
6. Clustering
7. Persistence
8. Streams
9. Case study: HMDA


---

# About me

* Solutions Architect @Chief, HMDA Team
* Have been doing GIS software development for +15 years
* Open Source contributor (GeoServer, GeoGit)
* Previously: 
  - CTO at Boundless
  - Lead Developer for the National Broadband Map at the FCC
  - Solutions Engineer at Esri

---

# Some background: the theory

* **Lambda Calculus:** is a formal system in mathematical logic for expressing computation based on function abstraction and application using binding and variable substitution. It is a universal model of computation equivalent to a Turing machine (Church-Turing Thesis, 1937)

* **Object-oriented programming (OOP)** is a programming paradigm based on the concept of "objects", which are data structures that contain data, in the form of fields, often known as attributes; and code, in the form of procedures, often known as methods (1970s, development of Smalltalk)

* The **Actor Model** is a mathematical model of concurrent computation that treats actors as the universal primitives for concurrent computation: in response to a message it receives, an actor can make local decisions, create more actors, send more messages, and determine how to respond to the next message received (Carl Hewit, 1973)

---

# Some background: the hardware problem

![Moore](img/moore.jpg)

---

# Some background: the software problem

![Amdal](img/AmdahlsLaw.png)

---


# The Reactive Manifesto

![Reactive Manifesto](img/reactive-traitsv2.png)

---
![Akka](img/akka_full_color.svg)

### _"Akka is a toolkit and runtime for building highly concurrent, distributed, and resilient message-driven applications on the JVM."_

---

# Actor Model

* Objects which encapsulate state and behavior
* Can only communicate with them by sending messages
* Mailbox (message queue) => process one message at a time
* They *share nothing* with other actors
* Event based processes, very lightweight. ~400 bytes in memory, millions / GB of RAM
* _Location Transparency_ => Distributable across a cluster of machines
* Two types of messages:
  - ! (bang operator) Fire and forget, returns inmmediately.
  - ? (ask operator) sends message and returns a Future representing a possible reply at a later point in time

---

# Fault Tolerance: supervision hierarchies


![Actor Supervision](img/actor-hierarchy.png)

---

# Actors: Hello World

```scala

case object Greeting

class HelloActor extends Actor {
  def receive = {
    case Greeting => println("Hello World")
    case _ => "I don't understand this message"
  }
}
```

In order to run this we need an `ActorSystem` (runtime) and we need to start the actor:

```scala
val system = ActorSystem("system")
val helloActor = system.actorOf(Props[HelloActor], "hello-actor")

```

Now we can send messages to it:

```scala
helloActor ! Greeting
```
---

# Actors example: Chat application

---

# Futures 

#### _A data structure used to retrieve the result of some concurrent operation. This result can be accessed synchronously (blocking) or asynchronously (non-blocking)_

Think of it as a read-only placeholder object for a result that doesn't exist yet

Futures require an `ExecutionContext` to work, it is similar to a `java.util.concurrent.Executor` and allows computations to operate in a new thread, a thread pool or on the current thread (the last option is discouraged).

The `scala.concurrent` package has `ExecutionContext.global` which is backed by a `ForkedJoinPool` thread pool, which allows programs to take advantage of multiple processors by submitting tasks to the pool thread. Execution contexts are configurable in Akka. 

---

# Futures: callbacks

```scala
import scala.util.{Success, Failure}

val f: Future[List[String]] = Future {
  session.getRecentPosts
}

f onComplete {
  case Success(posts) => for (post <- posts) println(post)
  case Failure(t) => println("An error has occured: " + t.getMessage)
}
```

You can also go just through the "happy path"

```scala
f onSuccess {
  case posts => for (post <- posts) println(post)
}
```

---
# Futures: Functional composition and for-comprehensions

Futures _compose_, allows us to describe parallel computations easily. The following code snippet will wait until both Futures have completed, then return

```scala
import scala.concurrent._
import scala.concurrent.duration._

def geocodePoint(parsed: ParsedAddress): Future[Point]
def geocodeCensus(parsed: ParsedAddress): Future[Point]

val r = for {
  p <- geocodePoint(address)
  c <- geocodeCensus(address)              
} yield (Result(p, c))

println(Await.result(r, 1 seconds))
```

*Important: * `Await.result` blocks until the future completes. Never use this in real code (it is OK for testing)

---
# Actors and Futures

The ask (`?`) operator returns a Future

```scala
val apiResponse: Future[String] = actorRef ? Request(payload:String)
```

This model is used a lot when sending messages through asynchronous boundaries. 
              
An alternative is to model the request-response cycle as a series of Actor messages (becomes more complicated, but has no timeout issues).

The result can be transformed using functional programming techniques:

```scala
val employeeList = (actorRef ? GetEmployees).mapTo[List[Employee]].map(_.name)
```

This will return a `Future[List[String]]`, it first gets a `Future[List[Employee]]` and then maps the result to each employee's name (a String)

---


# Utilities: Event Bus
A way to send messages to a group of actors. You can build your own by extending the API or use the `Event Stream`, the main event bus for an actor system. This allows publish / subscribe applications to be built easily. Event Stream is local only

```scala
abstract class AllKindsOfLoans { def id: String }
case class GoodLoan(id: String) extends AllKindsOfLoans
case class BadLoan(id: String) extends AllKindsOfLoans
  
class Listener extends Actor {
  def receive = {
    case g: GoodLoan => println(s"${self.path.name} is listening to: ${g.id}")
    case b: BadLoan  => println(s"${self.path.name} is listening to: ${b.id}")
  }
}
 
val goodLoanListener = system.actorOf(Props(classOf[Listener], this))
val allLoansListener = system.actorOf(Props(classOf[Listener], this))
system.eventStream.subscribe(goodLoanListener, classOf[GoodLoan])
system.eventStream.subscribe(allLoansListener, classOf[AllKindsOfLoans])
 
// only allLoansListener gets this message,
system.eventStream.publish(BadLoan("009"))
 
goodLoanListener and allLoansListener will be notified about GoodLoan:
system.eventStream.publish(GoodLoan("007"))
```
---


# Utilities: Akka Scheduler

When you want to send messsages to an actor at specific intervals.

```scala
val Tick = "tick"

class TickActor extends Actor {
  def receive = {
    case Tick => //Do something with Tick
  }
}

val tickActor = system.actorOf(Props(classOf[TickActor], this))
//Use system's dispatcher as ExecutionContext
import system.dispatcher
 
//This will schedule to send the Tick-message
//to the tickActor after 0ms repeating every 50ms
val cancellable =
  system.scheduler.schedule(0 milliseconds,
    50 milliseconds,
    tickActor,
    Tick)
 
//This cancels further Ticks to be sent
cancellable.cancel()
```

---

# Utilities: Akka Circuit Breaker

Used to prevent cascading failures in distributed systems. Isolates failures, avoiding one part of the system bringing everything down. 

Example: web api that overloads database, under failure condition you don't want it to receive more requests. The circuit breaker "opens" until the failure condition is resolved. 

![Circuit Breaker](img/circuit-breaker-states.png)

---

# Akka Cluster

#### _"Akka Cluster provides a fault-tolerant decentralized peer-to-peer based cluster membership service with no single point of failure or single point of bottleneck. It does this using gossip protocols and an automatic failure detector."_

![Akka Cluster](img/member-states.png)

---

# Akka Cluster: How to use

Akka Cluster only requires configuration. No code changes to your application!

```scala
akka {
  actor {
    provider = "akka.cluster.ClusterActorRefProvider"
  }
  remote {
    log-remote-lifecycle-events = off
    netty.tcp {
      hostname = "127.0.0.1"
      port = 0
    }
  }
 
  cluster {
    seed-nodes = [
      "akka.tcp://ClusterSystem@127.0.0.1:2551",
      "akka.tcp://ClusterSystem@127.0.0.1:2552"]
 
    auto-down-unreachable-after = 10s
  }
}
```

---

# Akka Cluster: Utilities

#### Distributed Publish Subscribe
  Allows publish / subscribe applications in clustered mode. Uses Cluster Singleton as mediator to route messages 
#### Singleton
  A Singleton Actor guarantees that only one copy of an Actor is present at once in the cluster. It will get restarted on another machine if the node fails.
#### Sharding
  Allows splitting your application across nodes and you want your actors to communicate with each other no matter which node they are running on.
  
#### Cluster Metrics Extension
  Provides runtime metrics for the cluster. Allows more complex routing of messages, i.e. send message to the node that is using less resources at a certain point in time

---

# Akka Cluster Example

---

# Akka Persistence

A mechanism to perform **Event Sourcing**

A pattern to mitigate the pitfalls of typical **CRUD** applications

It uses an append-only store to record all the events that happen in an application, not just the current state. State of an object can be obtained by replaying all the events associated with it. The stream of events has a complete **audit log** of what has happend with the application through time. 

**No data is lost, we can ask questions about the past**

---

# Akka Streams

Based on the [Reactive Streams](http://www.reactive-streams.org/) specification, it is still an experimental module (the API might change).

Akka Streams deals with the problem of handling streams of potentially infinite data in asynchronous systems. The difference with the Reactive Streams initiative is it's focus on handling `backpressure` through asynchronous boundaries (a REST API running remotely, another thread, another CPU, etc.)

![Backpressure](img/reactive-streams-backpressure.png)
---

# Akka Streams: the Graph API

These basic elements can be combined to create complex streaming data processing pipelines

#### Source
  A partial graph with exactly one output

#### Sink
  A partial graph with exactly one input

#### Flow
  A partial graph with exactly one input and exactly one output

![Graph](img/source-flow-sink.png)

---

# Akka Streams Example: Grasshopper

Streaming Batch Geocoder (http://github.com/cfpb/grasshopper)

![GeocodeFlow](img/geocode-flow.png)

In code:

```scala
address ~> broadcast
           broadcast.out(0) ~> geocodePointFlow         ~> zip.in0
           broadcast.out(1) ~> parse ~> geocodeLineFlow ~> zip.in1
           zip.out ~> response 
   
```

---


# Case Study: HMDA

### Home Mortgage Disclosure Act (HMDA)

* Provide the citizens and public officials of the U.S. sufficient information:
   - to enable them to determine whether covered institutions are filling their obligations to serve the housing needs of the communities and neighborhoods in which they are located; and 
   - to assist public officials in distributing public sector investments in a manner designed to improve the private environment.

* Assist in identifying possible discriminatory lending patterns and enforcing antidiscrimination statutes.

* Enhanced understanding of mortgage markets.

---

# HMDA: some challenges

* Data Ingestion
  - ~7500 Financial Institutions file individual loan data
  - 10 - 20 million records / year. Over 30 years of history
  - It all comes at the same time → huge spike

* Data publication
  - We don’t know what this will look like yet, but most likely we will have several different publication streams
  - Time to market. Now 6 months, we have to do 1 month (modified LAR). It should be 1 day or less
  - Most value is in time series and geographic analysis

* Data Management
  - We need to version every loan to keep track of it through time (100% audit trail)
  - We don’t know what questions we will ask of this data in the future
  - Data will grow significantly, adding new fields
  - Schema has changed and will change in the future

---

# HMDA Requirements

We need:

* Distributed deployment (many small systems, microservices)
* Fault tolerant (resilient to failure)
* Elastic (spike in traffic)
* Performance
* Time series
* 100% audit trail
* Data transformations
* Support for validating millions of records
* Every record goes through more than 150 validation rules

---

# How Akka fits the HMDA requirements

* Audit log with Akka Persistence
* Unknown publication needs benefit from Event Log (can replay and aggregate events in any new way)
* Distributed Rule Engine for fast validation
* We can use Scala Futures to perform tasks in parallel (i.e. run several validation rules on a single record at the same time)
* Akka Streams allows us to transform data in any way we need. No need for ETL tools
* Akka Cluster Sharding allows us to deploy thousands of Actors for LAR processing (at least one per Financial Institution), spreading the load across a cluster. If one fails it gets restarted, state is kept. 
* Akka Cluster Metrics Extension allows us to send processing of data to a node that is not as loaded as others in the cluster. 
* Akka Distributed PubSub extension allows us to send notifications across the cluster when certain events happen. Example: send email to FI when their data is public
* We can use Akka Circuit Breaker to ensure that we're not abusing external resources (i.e. Authentication Service)
* One of the biggest wins is leveraging the Actor Model and its Supervision Hierarchies. Makes for safe and fault tolerant applications







    </textarea>
    <script src="https://gnab.github.io/remark/downloads/remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create();
    </script>
  </body>
</html>
